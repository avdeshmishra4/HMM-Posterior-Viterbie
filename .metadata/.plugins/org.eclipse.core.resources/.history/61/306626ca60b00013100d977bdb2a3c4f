package dishonestcasino;

import java.io.BufferedWriter;
import java.io.IOException;

public class PosteriorPredictor {

	public double[][] forwardAlgorithm(String actualSequence, String obs,
			HiddenMarkovModel hmm, BufferedWriter bw, String stateSymbols[])
			throws IOException {

		int seqLen = obs.length();
		double forwardMatrix[][] = new double[hmm.getNumState()][seqLen + 1];

		double totalPath;
		double emProb;

		for (int i = 0; i < hmm.getNumState(); i++) {

			forwardMatrix[i][0] = hmm.getiProb()[i];

		}

		for (int k = 1; k < seqLen + 1; k++) {
			int transitionMatrixNoOfCol = 0;
			for (int l = 0; l < hmm.getNumState(); l++) {

				int stateCount = 0;
				double pathEndInFEmit = forwardMatrix[stateCount][k - 1];
				double pathEndInLEmit = forwardMatrix[stateCount + 1][k - 1];
				int curObs = Character.getNumericValue(obs.charAt(k - 1));

				totalPath = Math
						.log(Math.exp(pathEndInFEmit
								+ Math.log(hmm.getTransProb()[stateCount][transitionMatrixNoOfCol]))
								+ Math.exp(pathEndInLEmit
										+ Math.log(hmm.getTransProb()[stateCount + 1][transitionMatrixNoOfCol])));
				emProb = Math.log(hmm.getEmissProb()[l][curObs - 1]);

				forwardMatrix[l][k] = (emProb + totalPath) / 5;
				transitionMatrixNoOfCol++;

			}

		}

	//	System.out.println("implement");
		return forwardMatrix;

	}

	public void backwardAlogrithm(String actualSequence, String obs,
			HiddenMarkovModel hmm, BufferedWriter bw, String stateSymbols[],
			double[][] forwardMatrix) throws IOException {

		int seqLen = obs.length();
		double backwardMatrix[][] = new double[hmm.getNumState()][seqLen + 1];
		double emProbL;
		double emProbF;
		double fk1;
		double stateAssignmentF = 0;
		double stateAssignmentL = 0;
		int tpCount = 0;
		int tnCount = 0;
		int fpCount = 0;
		int fnCount = 0;
		double accuracy = 0;

		// considering the emission of end state as 1
		backwardMatrix[0][seqLen] = 1;
		backwardMatrix[1][seqLen] = 1;

		for (int i = backwardMatrix[0].length - 2; i >= 0; i--) {

			for (int j = hmm.getNumState() - 1; j >= 0; j--) {

				int stateCount = 0;
				double priorProbStateL = backwardMatrix[stateCount + 1][i + 1];
				double priorProbStateF = backwardMatrix[stateCount][i + 1];

				int curObs = Character.getNumericValue(obs.charAt(i));

				if (j == 1) {

					emProbL = Math.log(hmm.getEmissProb()[j][curObs - 1]);
					emProbF = Math.log(hmm.getEmissProb()[j - 1][curObs - 1]);

					backwardMatrix[j][i] = (Math
							.log(Math.exp(Math.log(hmm.getTransProb()[j][j])
									+ emProbL + priorProbStateL)) + Math
							.log(Math.exp(Math.log(hmm.getTransProb()[j][0])
									+ emProbF + priorProbStateF))) / 5;

				} else if (j == 0) {

					emProbL = Math.log(hmm.getEmissProb()[j + 1][curObs - 1]);
					emProbF = Math.log(hmm.getEmissProb()[j][curObs - 1]);

					backwardMatrix[j][i] = (Math
							.log(Math.exp(Math.log(hmm.getTransProb()[j][j])
									+ emProbF + priorProbStateF)) + Math
							.log(Math.exp(Math.log(hmm.getTransProb()[j][1])
									+ emProbL + priorProbStateL))) / 5;

				}

			}

		}

		// below is the code which identifies the predicted symbol generated by
		// posterior decoding

		int matrixLen = forwardMatrix[0].length - 1;
		StringBuilder sb = new StringBuilder();
		double maxValue;
		for (int k = 0; k < matrixLen; k++) {

			for (int l = 0; l < hmm.getNumState(); l++) {

				stateAssignmentF = forwardMatrix[l][k] * backwardMatrix[l][k]
						/ forwardMatrix[l][matrixLen];
				stateAssignmentL = forwardMatrix[l + 1][k]
						* backwardMatrix[l + 1][k]
						/ forwardMatrix[l][matrixLen];
				l++;

			}

			maxValue = Math.max(stateAssignmentF, stateAssignmentL);

			if (maxValue == stateAssignmentF) {

				sb.append("F");

			} else if (maxValue == stateAssignmentL) {

				sb.append("L");

			}

		}
		
		bw.write("Bkwd Algo :        "+sb.toString());
		String predictedSequence = sb.toString();
		bw.newLine();
		
		
		for (int j = 0; j < actualSequence.length(); j++) {

			if (actualSequence.charAt(j) == predictedSequence.charAt(j)
					&& actualSequence.charAt(j) == 'F') {

				tpCount = tpCount + 1;

			} else if (actualSequence.charAt(j) == predictedSequence
					.charAt(j) && actualSequence.charAt(j) == 'L') {

				tnCount = tnCount + 1;

			} else if (actualSequence.charAt(j) != predictedSequence
					.charAt(j)
					&& actualSequence.charAt(j) == 'F'
					&& predictedSequence.charAt(j) == 'L') {

				fpCount = fpCount + 1;

			} else if (actualSequence.charAt(j) != predictedSequence
					.charAt(j)
					&& actualSequence.charAt(j) == 'L'
					&& predictedSequence.charAt(j) == 'F') {

				fnCount = fnCount + 1;

			}

		}

		accuracy = (tpCount + tnCount) / (actualSequence.length() + 0.0);
		
		bw.write("Bkwd Accuracy :   "+ accuracy);
		bw.newLine();
		bw.newLine();
		

	}

}
