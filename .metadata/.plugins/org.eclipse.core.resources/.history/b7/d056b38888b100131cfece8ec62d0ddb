package dishonestcasino;

import java.io.BufferedWriter;
import java.io.IOException;

public class PosteriorPredictor {

	/*
	 * forwardAlgorithm takes generated sequence, observation sequence, HiddenMarkovModel, BufferedWriter, and state symbols as its argumnets
	 * 
	 * it generates the posterior forward matrix using posterior forward algorithm
	 *  
	 */
	
		
	public double[][] forwardAlgorithm(String actualSequence, String obs,
			HiddenMarkovModel hmm, BufferedWriter bw, String stateSymbols[])
			throws IOException {

		int seqLen = actualSequence.length();
		double forwardMatrix[][] = new double[hmm.getNumState()][seqLen + 1];

		for (int i = 0; i < hmm.getNumState(); i++) {

			forwardMatrix[i][0] = Math.log(hmm.getiProb()[i])/5;

		}

		for (int i = 1; i < seqLen + 1; i++) {

			for (int j = 0; j < hmm.getNumState(); j++) {

				int numState = 0;
				double sum = 0;
				while (numState < hmm.getNumState()) {

					sum = sum + forwardMatrix[numState][i - 1]
							+ Math.log(hmm.getTransProb()[numState][j]);
					numState++;

				}

				forwardMatrix[j][i] = (Math.log(hmm.getEmissProb()[j][Character
						.getNumericValue(obs.charAt(i - 1)) - 1]) + sum) / 5;

			}

		}

		return forwardMatrix;

	}
	
	
	/*
	 * backwardAlgorithm takes generated sequence, observation sequence, HiddenMarkovModel, BufferedWriter, state symbols and posterior forwardMatrix as its argumnets
	 * 
	 * it generates backward matrix using posterior decoding algorithm
	 * 
	 * it also generates the predicted state sequence based on posterior decoding algorithm
	 */
	

	public void backwardAlgorithm(String actualSequence, String obs, HiddenMarkovModel hmm,
			BufferedWriter bw, String stateSymbols[], double[][] forwardMatrix, BufferedWriter accuracyWriter)
			throws IOException {

		int seqLen = obs.length();
		double backwardMatrix[][] = new double[hmm.getNumState()][seqLen + 1];															// create backwardMatrix of row size number of states and column size sequence length+1 as ending state has
		double stateAssignmentF = 0;																									// probability 1 and to store end state we need one extra column					
		double stateAssignmentL = 0;
		

		// here the end of the matrix has one extra column to store the probability of end state with 1
		
		for (int x = 0; x < hmm.getNumState(); x++) {																					// initialize the last column of by 1

			backwardMatrix[x][backwardMatrix[x].length - 1] = 1;

		}

		for (int y = hmm.getNumState() - 1; y >= 0; y--) {																				// this loop implements the formula (fk(i) = ek(xi) SumOver-l fl(i – 1) alk) to calculate the sum
																																		// for the second last column as the emission probability of the last column is 1	
			double sum = 0;
			int numState = hmm.getNumState() - 1;
			while (numState > -1) {

				sum = sum
						+ Math.log(Math.exp(Math.log(hmm.getTransProb()[y][numState])
								+ 1
								+ backwardMatrix[numState][backwardMatrix[y].length - 1]));
				numState--;

			}
	//		System.out.println(backwardMatrix[y][backwardMatrix[y].length - 2] = sum / 5);

		}

		for (int i = backwardMatrix[0].length - 3; i >= 0; i--) {																		// this loop implements same algorithm of posterior decoding (fk(i) = ek(xi) SumOver-l fl(i – 1) alk) to calculate
																																		// sum and store it into the backward matrix by scaling it by scale factor (division by 5 as after some time the values in the matrix)
			for (int j = hmm.getNumState() - 1; j >= 0; j--) {																			// starts increasing in the negative range such as (-1000) and the exponential of this negative value gives Null values		

				double sum = 0;
				int numState = hmm.getNumState() - 1;
				while (numState > -1) {

					sum = sum
							+ Math.log(Math.exp(Math.log(hmm.getTransProb()[j][numState])
									+ Math.log(hmm.getEmissProb()[numState][Character
											.getNumericValue(obs.charAt(i + 1)) - 1])
									+ backwardMatrix[numState][i + 1]));

					numState--;

				}

				backwardMatrix[j][i] = sum / 5;																							// store the scaled value in a backward matrix

			}

		}

		// below is the code which identifies the predicted symbol generated by
		// posterior decoding

		int matrixLen = forwardMatrix[0].length - 1;
		StringBuilder sb = new StringBuilder();
		double maxValue;
		for (int k = 1; k <= matrixLen; k++) {																							// prediction of symbol emitted is done on the basis of posterior decoding algorithm

			for (int l = 0; l < hmm.getNumState(); l++) {																				// for each index postion and each state calculate the value of fk(i)*bk(i)/p(x) and take max over each state
																																		// whichever state generates the maximum value emmit that state symbol
				stateAssignmentF = forwardMatrix[l][k]
						* backwardMatrix[l][k - 1]
						/ forwardMatrix[l][matrixLen];
				stateAssignmentL = forwardMatrix[l + 1][k]
						* backwardMatrix[l + 1][k - 1]
						/ forwardMatrix[l][matrixLen];
				l++;

			}

			maxValue = Math.max(stateAssignmentF, stateAssignmentL);

			if (maxValue == stateAssignmentF) {

				sb.append("F");

			} else if (maxValue == stateAssignmentL) {

				sb.append("L");

			}

		}

		bw.write("Bkwd Algo :       " + sb.toString());																				// print the predicted sequence in output file
		String predictedSequence = sb.toString();	
		bw.newLine();	
		
		printAccuracy(actualSequence, predictedSequence, bw, accuracyBuffer, hmm);																		// to print accuracy of prediction call printAccuracy	

	}
	
	
	/*
	 * printAccuracy is the method which takes generated state sequence (actualSequence)  and posterior decoding predicted sequence and buffered writer
	 * 
	 * this method writes the accuracy of posterior decoding in an output file
	 */
	
	
	public void printAccuracy(String actualSequence, String predictedSequence,									
			BufferedWriter bw, BufferedWriter writeAccuracy, HiddenMarkovModel hmm) throws IOException {

		int tpCount = 0;
		int tnCount = 0;
		int fpCount = 0;
		int fnCount = 0;
		double accuracy = 0;
		
		

		for (int j = 0; j < actualSequence.length(); j++) {

			if (actualSequence.charAt(j) == predictedSequence.charAt(j)
					&& actualSequence.charAt(j) == 'F') {

				tpCount = tpCount + 1;

			} else if (actualSequence.charAt(j) == predictedSequence.charAt(j)
					&& actualSequence.charAt(j) == 'L') {

				tnCount = tnCount + 1;

			} else if (actualSequence.charAt(j) != predictedSequence.charAt(j)
					&& actualSequence.charAt(j) == 'F'
					&& predictedSequence.charAt(j) == 'L') {

				fpCount = fpCount + 1;

			} else if (actualSequence.charAt(j) != predictedSequence.charAt(j)
					&& actualSequence.charAt(j) == 'L'
					&& predictedSequence.charAt(j) == 'F') {

				fnCount = fnCount + 1;

			}

		}

		accuracy = (tpCount + tnCount) / (actualSequence.length() + 0.0);

		bw.write("Bkwd Accuracy :   " + accuracy);
		bw.newLine();
		bw.newLine();
		
		
		writeAccuracy.write("Transiton Fare To Loaded  : "+hmm.getTransProb(0, 1));
		writeAccuracy.newLine();
		writeAccuracy.write("Transiton Loaded To Fare  : "+hmm.getTransProb(0, 1));
		writeAccuracy.newLine();
		
		writeAccuracy.write("Number of False Positive  : "+fpCount);
		writeAccuracy.newLine();
		writeAccuracy.write("Number of False Negattive : "+fnCount);
		writeAccuracy.newLine();
		writeAccuracy.write("Accuracy                  : "+accuracy);
		writeAccuracy.newLine();
		writeAccuracy.newLine();
		
		
		

	}
	
	
	
}
